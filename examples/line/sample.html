<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font: 10px sans-serif;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.x.axis path {
  display: none;
}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.js"></script>
<script>

// PART: Setup some data

var data = [
];

var addData = function(date, austin, kc){
  var getSeries = function(key){
    var i=0, l=data.length;
    for(; i<l; i++){
      if(data[i].name===key){
        return data[i].values;
      }
    }
    var res = {
      name: key,
      values: []
    };
    data.push(res);
    return res.values;
  };
  /*
  data.push({
      date: date,
      austin: austin,
      kc: kc
    });
  */
  getSeries('KC').push({
    date: new Date(date),
    value: kc
  });
  getSeries('Austin').push({
    date: new Date(date),
    value: austin
  });
};

var parseDate = d3.time.format("%m/%d/%Y").parse;

addData('01/01/2014', 5, 10);
addData('01/15/2014', 8, 20);
addData('02/01/2014', 3, 30);
addData('03/01/2014', 20, 40);
addData('04/01/2014', 10, 15);
addData('05/01/2014', 2, 20);

console.log(data);


var data = (function(num, size){
  var data = [], series;
  var i, l=size, j=0, k=num;
  for(; j<k; j++){
    series = {name: 'Series '+j, values: []};
    for(i=0; i<l; i++){
      series.values.push({
        value: Math.floor(Math.random() * 90)+10,
        index: i,
        text: "Series "+j+" - Value "+i
      });
    }
    data.push(series);
  }
  return data;
})(3, 10);


// PART: Setup graph properties

var margin = {top: 20, right: 80, bottom: 30, left: 50};
var width = 960;
var height = 500;
var yAxisTitle = 'Temperature (ÂºF)';
var seriesNames = function(d){
  return d.name;
};

var seriesValues = function(d){
  return d.values;
};

var pointIndexes = function(d, i){
  //var e = new Error();
  //console.log(d, i, e.stack);
  return i;//d.index;
};

var pointValues = function(d){
  return d.value;
};

var w = width - margin.left - margin.right;
var h = height - margin.top - margin.bottom;

var x = d3.time.scale()
    .range([0, w]);

var y = d3.scale.linear()
    .range([h, 0]);

var color = d3.scale.category10();

var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");

var line = d3.svg.line()
    //.interpolate("basis") // a B-spline, with control point duplication on the ends
    //.interpolate("basis-open") // an open B-spline; may not intersect the start or end
    //.interpolate("basis-closed") // a closed B-spline, as in a loop
    //.interpolate("linear")// (Default) straight line between points
    //.interpolate("linear-closed")// straight line between points with a returning line to the start point
    //.interpolate("step")// show changes using steps
    //.interpolate("step-before")// show changes with a step before the data changes
    //.interpolate("step-after")// show changes with a step after the data changes
    //.x(function(d, i) { console.log('x', d, i, x(pointIndexes(d, i))); return x(pointIndexes(d, i)); })
    .x(function(d, i) { return x(pointIndexes(d, i)); })
    .y(function(d, i) { return y(pointValues(d, i)); });

// PART: Start rendering graph
  var svg = d3.select("body").append("svg")
    .attr("width", w + margin.left + margin.right)
    .attr("height", h + margin.top + margin.bottom)
    .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var names = data.map(seriesNames);
  color.domain(names);

var indexes = data.map(seriesValues).map(function(list){
  return list.map(pointIndexes);
}).reduce(function(curr, res){
  return res.concat(curr);
}, []);
console.log(d3.extent(indexes));
console.log(d3.extent(data.map(seriesValues).reduce(function(res, curr){
  return res.concat(curr);
}, []), pointIndexes));
x.domain(d3.extent(indexes));
/*
  x.domain(d3.extent(data.map(seriesValues).reduce(function(res, curr){
    return res.concat(curr);
  }, []), pointIndexes));
*/

  y.domain([
    d3.min(data, function(c) { return d3.min(seriesValues(c), pointValues); }),
    d3.max(data, function(c) { return d3.max(seriesValues(c), pointValues); })
  ]);

  svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + h + ")")
      .call(xAxis);

  if(yAxisTitle){
    svg.append("g")
        .attr("class", "y axis")
        .call(yAxis)
        .append("text")
          .attr("transform", "rotate(-90)")
          .attr("y", 6)
          .attr("dy", ".71em")
          .style("text-anchor", "end")
          .text(yAxisTitle);
  }

  var series = svg.selectAll(".series")
      .data(data)
      .enter().append("g")
        .attr("class", "series");

  series.append("path")
      .attr("class", "line")
      .attr("d", function(d) {
                   return line(seriesValues(d));
                 })
      .style("stroke", function(d) { return color(seriesNames(d)); });
  series.append("text")
      .datum(function(d, i){
          //console.log('datum: ', d, i);
          var values = seriesValues(d);
          return {name: seriesNames(d), value: values[values.length - 1]};
        })
      .attr("transform", function(d, i) {
          //console.log('transform: ', d, i);
          return "translate(" + x(pointIndexes(d.value, i)) + "," + y(pointValues(d.value, i)) + ")";
        })
      .attr("x", 3)
      .attr("dy", ".35em")
      .text(function(d) { return d.name; });
</script>
</body>
